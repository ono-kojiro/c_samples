/* Generated by re2c 3.0 on Sun Oct 16 13:11:01 2022 */
#line 1 "scanner.re"
// re2c $INPUT -o $OUTPUT
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scanner.h"
#
#line 12 "scanner.c"
#define YYMAXFILL 6
#line 9 "scanner.re"

#define BUFSIZE (4096 - YYMAXFILL)

struct Input {
    FILE *file;
    char buf[BUFSIZE + YYMAXFILL], *lim, *cur, *tok, *mar;
    int eof;
};

static int fill(struct Input *in, size_t need) {
    if (in->eof) return 1;

    const size_t shift = in->tok - in->buf;
    const size_t used = in->lim - in->tok;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (shift < need) return 2;

    // Shift buffer contents (discard everything up to the current token).
    memmove(in->buf, in->tok, used);
    in->lim -= shift;
    in->cur -= shift;
    in->tok -= shift;
    in->mar -= shift;

    // Fill free space at the end of buffer with new data from file.
    in->lim += fread(in->lim, 1, BUFSIZE - used, in->file);

    // If read less than expected, this is end of input => add zero padding
    // so that the lexer can access characters at the end of buffer.
    if (in->lim < in->buf + BUFSIZE) {
        in->eof = 1;
        memset(in->lim, 0, YYMAXFILL);
        in->lim += YYMAXFILL;
    }

    return 0;
}

static int lex(struct Input *in) {
    int count = 0;
	//fprintf(stderr, "%s(%d) : lex start\n", __FILE__ , __LINE__ );
    for (;;) {
        in->tok = in->cur;
    
#line 60 "scanner.c"
{
	char yych;
	if ((in->lim - in->cur) < 6) if (fill(in, 6) != 0) return -1;(6);
	yych = *in->cur;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case '\v':
		case ' ': goto yy4;
		case '\n': goto yy6;
		case '\r': goto yy8;
		case '1': goto yy9;
		case 'n': goto yy10;
		case 'o': goto yy11;
		default: goto yy2;
	}
yy1:
	++in->cur;
#line 75 "scanner.re"
	{
            fprintf(stderr, " (END) ");
            fprintf(stderr, "\n");
            RET(END);
        }
#line 85 "scanner.c"
yy2:
	++in->cur;
yy3:
#line 104 "scanner.re"
	{
           fprintf(stderr, " (ANY:%.*s) ", in->cur - in->tok, in->tok);
           RET(ANY);
        }
#line 94 "scanner.c"
yy4:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '\t':
		case '\v':
		case ' ': goto yy4;
		default: goto yy5;
	}
yy5:
#line 95 "scanner.re"
	{
            continue;
        }
#line 110 "scanner.c"
yy6:
	++in->cur;
yy7:
#line 91 "scanner.re"
	{
            RET(NL);
        }
#line 118 "scanner.c"
yy8:
	yych = *++in->cur;
	switch (yych) {
		case '\n': goto yy6;
		default: goto yy7;
	}
yy9:
	yych = *(in->mar = ++in->cur);
	switch (yych) {
		case '.': goto yy12;
		default: goto yy3;
	}
yy10:
	yych = *(in->mar = ++in->cur);
	switch (yych) {
		case 'o': goto yy14;
		default: goto yy3;
	}
yy11:
	yych = *++in->cur;
	switch (yych) {
		case 'k': goto yy15;
		default: goto yy3;
	}
yy12:
	yych = *++in->cur;
	switch (yych) {
		case '.': goto yy16;
		default: goto yy13;
	}
yy13:
	in->cur = in->mar;
	goto yy3;
yy14:
	yych = *++in->cur;
	switch (yych) {
		case 't': goto yy17;
		default: goto yy13;
	}
yy15:
	++in->cur;
#line 86 "scanner.re"
	{
            fprintf(stderr, " (TESTPOINT) ");
            RET(TESTPOINT);
        }
#line 165 "scanner.c"
yy16:
	yych = *++in->cur;
	switch (yych) {
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy18;
		default: goto yy13;
	}
yy17:
	yych = *++in->cur;
	switch (yych) {
		case ' ': goto yy20;
		default: goto yy13;
	}
yy18:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy18;
		default: goto yy19;
	}
yy19:
#line 81 "scanner.re"
	{
            fprintf(stderr, " (PLAN) ");
            RET(PLAN);
        }
#line 209 "scanner.c"
yy20:
	yych = *++in->cur;
	switch (yych) {
		case 'o': goto yy21;
		default: goto yy13;
	}
yy21:
	yych = *++in->cur;
	switch (yych) {
		case 'k': goto yy15;
		default: goto yy13;
	}
}
#line 108 "scanner.re"

    }
}

SCANNER *Scanner_Create()
{
  struct Input *self = NULL;
  self = (struct Input *)malloc(1 * sizeof(struct Input));
  memset(self, 0, sizeof(struct Input));

  return (SCANNER *)self;
}

int Scanner_Delete(SCANNER *s)
{
  free(s);
}

int Scanner_Init(SCANNER *s)
{
  struct Input *self = (struct Input *)s;
  self->cur = self->tok = self->lim = self->buf + BUFSIZE;
  self->eof = 0;
  if(self->file){
    fclose(self->file);
  }
  self->file = NULL;
  return 0;
}

int Scanner_Open(SCANNER *s, const char *filename)
{
  int ret = 0;
  struct Input *self = (struct Input *)s;
  if(self->file){
    fclose(self->file);
  }
  self->file = fopen(filename, "r");
  if(!self->file){
    fprintf(stderr, "ERROR : can not open %s\n", filename);
	ret = 1;
  }

  return ret;
}

int Scanner_GetBufSize(SCANNER *s)
{
  return BUFSIZE;
}

int Scanner_Scan(SCANNER *s, int *id)
{
  int retval;

  struct Input *self = (struct Input *)s;
  retval = lex(self);
  *id = retval;

  if(retval == ANY){
    retval = 1;
  }
  else if(retval == END){
    retval = -1;
  }
  else {
    retval = 0;
  }

  return retval;
}

#if 0
int main() {
    const char *fname = "input";
    const char content[] = "'qu\0tes' 'are' 'fine: \\'' ";

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    FILE *f = fopen(fname, "w");
    for (int i = 0; i < BUFSIZE; ++i) {
        fwrite(content, 1, sizeof(content) - 1, f);
    }
    fclose(f);
    int count = 3 * BUFSIZE; // number of quoted strings written to file

    // Initialize lexer state: all pointers are at the end of buffer.
    // This immediately triggers YYFILL, as the check `in.cur < in.lim` fails.
    struct Input in;
    in.file = fopen(fname, "r");
    in.cur = in.tok = in.lim = in.buf + BUFSIZE;
    in.eof = 0;

    // Run the lexer.
    assert(lex(&in) == count);

    // Cleanup: remove input file.
    fclose(in.file);
    remove(fname);
    return 0;
}
#endif
