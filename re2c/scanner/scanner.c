/* Generated by re2c 3.0 on Sun Oct 16 10:25:39 2022 */
#line 1 "scanner.re"
// re2c $INPUT -o $OUTPUT
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "scanner.h"
#
#line 12 "scanner.c"
#define YYMAXFILL 3
#line 9 "scanner.re"

#define BUFSIZE (4096 - YYMAXFILL)

struct Input {
    FILE *file;
    char buf[BUFSIZE + YYMAXFILL], *lim, *cur, *tok, *mar;
    int eof;
};

static int fill(struct Input *in, size_t need) {
    if (in->eof) return 1;

    const size_t shift = in->tok - in->buf;
    const size_t used = in->lim - in->tok;

    // Error: lexeme too long. In real life could reallocate a larger buffer.
    if (shift < need) return 2;

    // Shift buffer contents (discard everything up to the current token).
    memmove(in->buf, in->tok, used);
    in->lim -= shift;
    in->cur -= shift;
    in->tok -= shift;
    in->mar -= shift;

    // Fill free space at the end of buffer with new data from file.
    in->lim += fread(in->lim, 1, BUFSIZE - used, in->file);

    // If read less than expected, this is end of input => add zero padding
    // so that the lexer can access characters at the end of buffer.
    if (in->lim < in->buf + BUFSIZE) {
        in->eof = 1;
        memset(in->lim, 0, YYMAXFILL);
        in->lim += YYMAXFILL;
    }

    return 0;
}

static int lex(struct Input *in) {
    int count = 0;
	//fprintf(stderr, "%s(%d) : lex start\n", __FILE__ , __LINE__ );
    for (;;) {
        in->tok = in->cur;
    
#line 60 "scanner.c"
{
	char yych;
	if ((in->lim - in->cur) < 3) if (fill(in, 3) != 0) return -1;(3);
	yych = *in->cur;
	switch (yych) {
		case 0x00: goto yy1;
		case '\t':
		case '\v':
		case ' ': goto yy3;
		case '\n': goto yy5;
		case '\r': goto yy7;
		case '\'': goto yy8;
		case '0': goto yy9;
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy11;
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy13;
		default: goto yy2;
	}
yy1:
	++in->cur;
#line 72 "scanner.re"
	{
            fprintf(stderr, " (END) ");
            fprintf(stderr, "\n");
            RET(END);
        }
#line 146 "scanner.c"
yy2:
	++in->cur;
#line 111 "scanner.re"
	{
           fprintf(stderr, " (ANY:%.*s) ", in->cur - in->tok, in->tok);
           RET(ANY);
        }
#line 154 "scanner.c"
yy3:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '\t':
		case '\v':
		case ' ': goto yy3;
		default: goto yy4;
	}
yy4:
#line 101 "scanner.re"
	{
            fprintf(stderr, " (WS) ");
            RET(WS);
        }
#line 171 "scanner.c"
yy5:
	++in->cur;
yy6:
#line 106 "scanner.re"
	{
            fprintf(stderr, " (NL)\n");
            RET(NL);
        }
#line 180 "scanner.c"
yy7:
	yych = *++in->cur;
	switch (yych) {
		case '\n': goto yy5;
		default: goto yy6;
	}
yy8:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '\'': goto yy15;
		case '\\': goto yy16;
		default: goto yy8;
	}
yy9:
	yych = *(in->mar = ++in->cur);
	switch (yych) {
		case 'x': goto yy19;
		default: goto yy18;
	}
yy10:
#line 87 "scanner.re"
	{
            fprintf(stderr, " (OCT:%.*s) ", in->cur - in->tok, in->tok);
            RET(OCT);
        }
#line 208 "scanner.c"
yy11:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9': goto yy11;
		default: goto yy12;
	}
yy12:
#line 92 "scanner.re"
	{
            fprintf(stderr, " (DEC:%.*s) ", in->cur - in->tok, in->tok);
            RET(DEC);
        }
#line 232 "scanner.c"
yy13:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
		case 'H':
		case 'I':
		case 'J':
		case 'K':
		case 'L':
		case 'M':
		case 'N':
		case 'O':
		case 'P':
		case 'Q':
		case 'R':
		case 'S':
		case 'T':
		case 'U':
		case 'V':
		case 'W':
		case 'X':
		case 'Y':
		case 'Z':
		case '_':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
		case 'g':
		case 'h':
		case 'i':
		case 'j':
		case 'k':
		case 'l':
		case 'm':
		case 'n':
		case 'o':
		case 'p':
		case 'q':
		case 'r':
		case 's':
		case 't':
		case 'u':
		case 'v':
		case 'w':
		case 'x':
		case 'y':
		case 'z': goto yy13;
		default: goto yy14;
	}
yy14:
#line 82 "scanner.re"
	{
            fprintf(stderr, " (ID:%.*s) ", in->cur - in->tok, in->tok);
            RET(ID);
        }
#line 309 "scanner.c"
yy15:
	++in->cur;
#line 78 "scanner.re"
	{ ++count;
            fprintf(stderr, " (STR:%.*s) ", in->cur - in->tok, in->tok);
            RET(STR);
        }
#line 317 "scanner.c"
yy16:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	goto yy8;
yy17:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
yy18:
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7': goto yy17;
		default: goto yy10;
	}
yy19:
	yych = *++in->cur;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f': goto yy21;
		default: goto yy20;
	}
yy20:
	in->cur = in->mar;
	goto yy10;
yy21:
	++in->cur;
	if (in->lim <= in->cur) if (fill(in, 1) != 0) return -1;(1);
	yych = *in->cur;
	switch (yych) {
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f': goto yy21;
		default: goto yy22;
	}
yy22:
#line 96 "scanner.re"
	{
            fprintf(stderr, " (HEX:%.*s) ", in->cur - in->tok, in->tok);
            RET(HEX);
        }
#line 403 "scanner.c"
}
#line 115 "scanner.re"

    }
}

SCANNER *Scanner_Create()
{
  struct Input *self = NULL;
  self = (struct Input *)malloc(1 * sizeof(struct Input));
  memset(self, 0, sizeof(struct Input));

  return (SCANNER *)self;
}

int Scanner_Delete(SCANNER *s)
{
  free(s);
}

int Scanner_Init(SCANNER *s)
{
  struct Input *self = (struct Input *)s;
  self->cur = self->tok = self->lim = self->buf + BUFSIZE;
  self->eof = 0;
  if(self->file){
    fclose(self->file);
  }
  self->file = NULL;
  return 0;
}

int Scanner_Open(SCANNER *s, const char *filename)
{
  int ret = 0;
  struct Input *self = (struct Input *)s;
  if(self->file){
    fclose(self->file);
  }
  self->file = fopen(filename, "r");
  if(!self->file){
    fprintf(stderr, "ERROR : can not open %s\n", filename);
	ret = 1;
  }

  return ret;
}

int Scanner_GetBufSize(SCANNER *s)
{
  return BUFSIZE;
}

int Scanner_Scan(SCANNER *s, int *id)
{
  int retval;

  struct Input *self = (struct Input *)s;
  retval = lex(self);
  *id = retval;

  if(retval == ANY){
    retval = 1;
  }
  else if(retval == END){
    retval = -1;
  }
  else {
    retval = 0;
  }

  return retval;
}

#if 0
int main() {
    const char *fname = "input";
    const char content[] = "'qu\0tes' 'are' 'fine: \\'' ";

    // Prepare input file: a few times the size of the buffer, containing
    // strings with zeroes and escaped quotes.
    FILE *f = fopen(fname, "w");
    for (int i = 0; i < BUFSIZE; ++i) {
        fwrite(content, 1, sizeof(content) - 1, f);
    }
    fclose(f);
    int count = 3 * BUFSIZE; // number of quoted strings written to file

    // Initialize lexer state: all pointers are at the end of buffer.
    // This immediately triggers YYFILL, as the check `in.cur < in.lim` fails.
    struct Input in;
    in.file = fopen(fname, "r");
    in.cur = in.tok = in.lim = in.buf + BUFSIZE;
    in.eof = 0;

    // Run the lexer.
    assert(lex(&in) == count);

    // Cleanup: remove input file.
    fclose(in.file);
    remove(fname);
    return 0;
}
#endif
